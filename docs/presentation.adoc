= Unter der Haube: Deep Dive 4 – Die wichtigsten Neuerungen seit Java 11
:author: Benjamin Schmid @bentolor <ben@tolor.de>
:date: 2021-09-14
:icons: font
// we want local served fonts. Therefore patched sky.css
//:revealjs_theme: sky
:revealjs_customtheme: css/sky.css
//:revealjs_autoSlide: 5000
:revealjs_history: true
:revealjs_fragmentInURL: true
:revealjs_viewDistance: 5
:revealjs_width: 1408
:revealjs_height: 792
:revealjs_controls: false
:revealjs_controlsLayout: edges
:revealjs_controlsTutorial: true
:revealjs_slideNumber: c/t
:revealjs_showSlideNumber: speaker
:revealjs_autoPlayMedia: true
:revealjs_defaultTiming: 42
//:revealjs_transitionSpeed: fast
:revealjs_parallaxBackgroundImage: images/background-landscape-light-orange.jpg
:revealjs_parallaxBackgroundSize: 4936px 2092px
:customcss: css/presentation.css
:imagesdir: images
:source-highlighter: highlightjs
:highlightjs-theme: css/atom-one-light.css
// we want local served font-awesome fonts
:iconfont-remote!:
:iconfont-name: fonts/fontawesome/css/all



== Motor-Upgrade: 3 Kleinigkeiten
=== Exception Error
=== Schnellere GC
=== Einfachere CDS / JFR Zeitreisen?


[.lightbg,background-video="coffee-beans.mp4",background-video-loop="true",background-opacity="0.7"]
== Java 12--17 in a nutshell

=== v9 (huge…)

* *Java module (Jigsaw)*
* *API Improvements:* _Project Coin Milling_, Stream, … 
* *Unified JVM & Java Logging*, …
//  Reflection, Date, Concurrency, …
// * _Deprecated:_ `finalize()` 
* *Performance*
* _Tools:_ `jshell` `jlink` `-release`, Multi-Release JARs
//* _New platforms:_ *AArch64, s390x, Arm32/Arm64*

[decent]#2017-03-23, icon:exclamation-circle[] http://openjdk.java.net/projects/jdk9/[*91* JEPs]#

=== Recap

> Auch Blick unter die Haube lohnt sich; manche transaprent & für alle; manche muss man sich erschließen
[.notes]
--
* Viele Änderungen unter der Haube
* Einige auch nicht so präsent, z.B. Shennandoah GC
* Blick unter die "Haube", also JVM, Tools und JVM Internals
--


[.lightbg,background-video="relaxing.mp4",background-video-loop="true",background-opacity="0.7"]
== Agenda
1. Native
//** Vector API
//** Native Memory/Function
2. Diagnostik
//** JFR / JMC
3. Memory Management
4. Tools
5. Details & Maintenance

== Native

== Vector API


== Class Data Sharing 


=== Class Data-Sharing in a Nutshell

Class Data-Sharing::
[emphasize]#Reduziert Startzeiten & Speicherbedarf# von JVMs durch `.jsa` Archiv mit Metadaten der Klassen.
+
→ Klassen liegen damit vorgeparsed in _direkt für die JVM verwendbarem_ Format vor. Das Archiv kann _read-only_ eingebunden werden, was dem OS _Caching_ & _Sharing_ erlaubt.
+
**Achtung:** Archive sind JVM Plattform- und Versionspezifisch!

Application Class-Data Sharing (AppCDS)::
Erlaubt zusätzlich Applikations-Klassen in das CDS aufzunehmen

=== Neuerungen im Bereich CDS

Default CDS Archive [version]#12# [jep]#https://openjdk.java.net/jeps/341[JEP 341]#::
JVM liefert nun per Default ein `classes.jsa` CDS-Archiv mit aus, welches ein Subset der häufigsten JDK-Klassen umfasst.

Dynamic CDS Archive [version]#13# [jep]#https://openjdk.java.net/jeps/350[JEP 350]#::
Vereinfacht erheblich die Erstellung eigener AppCDS Archive durch automatische Auswahl und Archiverzeugung beim beenden der Java-Applikation.


=== AppCDS Archiverstellung

.Erstellung über Liste [version]#11#
[source,shell]
----
$ java -Xshare:off -XX:DumpLoadedClassList=myclasses.txt -cp myapp.jar MyApp

$ java -Xshare:dump -XX:SharedArchiveFile=myapp.jsa \
       -XX:SharedClassListFile=myclasses.txt -cp myapp.jar
----

[.fragment]
.Nutzung des AppCDS-Archives
[source,shell]
----
$ java -XX:SharedArchiveFile=myapp.jsa -cp myapp.jar MyApp
----

[.fragment]
.NEU: Automatische Erstellung [version]#13#
[source,shell]
----
$ java -XX:ArchiveClassesAtExit=myapp.jsa -cp myapp.jar MyApp
----


[%notitle]
=== AppCDS Gewinne
image::app_cds_time_to_first_response.png[AppCDS Startup Times,height=700]
[.refs.xx-small]
--
Quelle: https://www.morling.dev/blog/building-class-data-sharing-archives-with-apache-maven/
--
[.notes]
--
* Teils bis zu 40% Reduktion in Startup-Times
* Noch mehr Potential mit Kombination von `jlink`
* Quelle hier: Gunnar Morling
--


== GraalVM
=== Überblick & Stand
* Polyglott VM
* SubstrateVM: AoT Compiler
* GraalVM Community & Enterprise

//[%notitle,background-image="graalvm-architecture.png"]
=== Project Metropolis
image::graalvm-architecture.png[GraalVM ecosystem]

[.notes]
--
* Polyglot VM: Execute multiple language with zero overhead
* Can run in multiple environments; Can produce native images
* Zero-overhead interop
--

=== GraalVM -- Polyglot VM [jep]#https://openjdk.java.net/jeps/243[JEP 243]# [jep]#https://openjdk.java.net/jeps/246[JEP 246]# [jep]#https://openjdk.java.net/jeps/295[JEP 295]#
[.col2]
--
* *Ahead-of time compiler* (AoT)
* Generic VM +
 for *different languages* +
→ _JVM_ (Java, Kotlin, Scala, …) +
→ _LLVM_ (C, C++) → native +
→ _Java_ Script, Python, Ruby, R
--
[.col2]
--
* Shared Runtime → Zero overhead for language interop
* *Native executables* +
  (GraalVM on SubstrateVM) +
  → Much smaller startup & memory
--
[.clear.decent]
--
.AoT can be used today:
[.x-small]#`java -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler`#
--
[.notes]
--
* Multiple parts:
** AoT Compiler
** Graal VM / Substrate VM as runtime
* AoT → improved startup time vs. JIT
* Limitations: Dynamic (Reflection); highly experimental
* AoT Compile can be used today
--

=== Frameworks
* Helidon, Quarkus.io, Micronaut, (?Spring Fu, Javalin, Ktor, Vert.x)
* zielen auf GraalVM AoT Compilation & Microservices
* z.B. Dependency Resolver zur Compiletime via Annotation Processing vs. Laufzeit
* Java CLI native image

=== Demo
* xxx

== Memory Management
=== Überblick Änderungen GC 
* ZGC Concurrent Class Unloading [version]#12#
* ZGC Uncommit Unused Memory [jep]#https://openjdk.java.net/jeps/351[JEP 351]# [version]#13#
* ZGC on macOS [jep]#https://openjdk.java.net/jeps/364[JEP 364]# [version]#14# 
* ZGC on Windows [jep]#https://openjdk.java.net/jeps/365[JEP 365]# [version]#14# 
* ZGC Production-Ready [jep]#https://openjdk.java.net/jeps/377[JEP 377] #[version]#15#
* ZGC -XXSoftMaxHeapSize Flag  [version]#13#
* ZGC Maximum Heap Size Increased to 16TB [version]#13#
* ZGC Concurrent Stack Processing [jep]#https://openjdk.java.net/jeps/376[JEP 376]  [version]#16#
* Allocation of Old Generation of Java Heap on Alternate Memory Devices [version]#12#
* G1 May Uncommit Memory During Marking Cycle [version]#12#
* G1 Improve Ergonomics for Sparse PRT Entry Size [version]#13#
* Serial GC Improvements in Young pause time report [version]#13#
* Parallel GC Improvements [version]#14#
* NUMA-Aware Memory Allocation for G1 [jep]#https://openjdk.java.net/jeps/354[JEP 354] [version]#14#
* CMS: Remove Concurrent Mark and Sweep GC [jep]#https://openjdk.java.net/jeps/363[JEP 363] [version]#14#
* ParallOldGC: Deprecate SerialOld [jep]#https://openjdk.java.net/jeps/366[JEP 366] [version]#14#
* Shenandoah self-fixing barriers [version]#14#
*  Epsilon warns about Xms/Xmx/AlwaysPreTouch configuration [version]#14#
* Shenandoah asynchronous object/region pinning [version]#14#
* Shenandoah: A Low-Pause-Time Garbage Collector (Production [jep]#https://openjdk.java.net/jeps/379[JEP 379] [version]#15#
* Epsilon does not extend TLABs to max size [version]#14#
* Shenandoah supports concurrent class unloading [version]#14#
* Shenandoah arraycopy improvements [version]#14#
* ParallelGC Obsolete -XXUseAdaptiveGCBoundary [version]#15#
* G1 Improved Ergonomics for Heap Region Size [version]#15#
* Bug: Disabling large pages on Windows [version]#15#
* Bug: Disabling NUMA Interleaving on Windows [version]#15#
* G1 Concurrently Uncommit Memory [version]#16#
* ParallelGC Enables Adaptive Parallel Reference Processing by Default  [version]#17#
* Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)  [jep]#https://openjdk.java.net/jeps/189[JEP 189] [version]#12#


[.notes]
--
* The Z Garbage Collector now supports class unloading.
* Experimental feature in G1 & Parallel GC allows OldGen on NV-DIMM memory.
* G1 may now give back Java heap memory to the operating system during any concurrent mark cycle.
--

=== GC: ZGC
 Z Garbage Collector (ZGC):: 
  * A scalable low-latency garbage collector. 
  * Motivation: long GC pauses for app responses
  * Goals: Pauses <10ms, typical 2ms
  * Less 15% Throughput drop vs. G1
  * Heap 8MB~16TB, Linux/Win/macOS
  * _"Colored Pointers"_ → Object Relocation
  * Enable: `-XX:+UseZGC`
  * Production since JDK 15

=== GC: Shennadoah

Shenandoah::
  * A Low-Pause-Time Garbage Collector by concurrent evacuation work
  * Pause times with Shenandoah are independent of heap size
  * appropriate if priority on responsiveness and predictable short pauses
  * trades concurrent cpu cycles and space for pause time improvements
  * Intro in JDK 12
  * Production since JDK 15
  * `-XX:+UseShenandoahGC`

=== GC: Vergleich

* Shenandoah: Pause times with Shenandoah are independent of heap size. Trades concurrent cpu cycles and space for pause time improvements.

* Zing/Azul has a pauseless collector, however that work has not been contributed to OpenJDK.

* ZGC has a low pause collector based on colored pointers. We look forward to comparing the performance of the two strategies.

* G1 mostly concurrent, but it does not do concurrent evacuation. Strategy: "slice up GC pauses according to a user-supplied time target". Will be selected by on most hardware. Pauses: 250ms~850ms. High throughput

* CMS does concurrent marking, but it performs young generation copying at pause times, and never compacts the old generation. 

.Alte GCs

Pausen steigen mit wachsenden Heaps

* SerialGC:  all GC work on a single thread. Nur bis ~100MB Heap empfohlen.

* ParallelGC selects the parallel (throughput) collector, which can perform compaction using multiple threads. Pauses: 200~300ms. Hocher durchsatz

=== GC: G1 & andere
=== Fazit
* ggf. Performance Vergleich o.ä.
* G1 gibt Speicher schneller frei

[.notes]
--
https://blogs.oracle.com/javamagazine/understanding-the-jdks-new-superfast-garbage-collectors
https://docs.oracle.com/en/java/javase/17/gctuning/available-collectors.html
--


== JDK Flight Recorder (JFR)

=== JDK Flight Recorder (JFR) [jep]#https://openjdk.java.net/jeps/328[JEP 328]#
* OS, JVM, JDK & App Diagnostik
* extrem geringer Overhead (~1%)
* built-in & jederzeit aktivierbar
* always-on möglich → Timemachine

[.emphasize.fragment]
→ icon:cogs[] **Production** Profiling & Monitoring

[.decent.x-small]


[.notes]
--
* Ehemals kommerzielles JVM Addon "Java Flight Recorder" 
* seit Java 11 OpenJDK Bestandteil 
* Aktivierbar für neue und *bereits laufende* Java-Instanzen
* Zielmetrik: Weniger als 1% Overhead → no measurable impact on the running application →  klare Ausrichtung für Produktionsverwendung
* Built by the JVM/JDK people 
** → access to data already collected, more accurate, faster
** Safe and reliable in production 
* always on  →  Time machine – just dump the recording data when a problem occurs, and see what the runtime was up to before, up to, and right after the problem occurred.
* Even on JVM crash → JFR data avail in dump

JDK Mission Control also contains other tools, such as a JMX Console, and HPROF-dump analyzer and more.
--




[%notitle]
=== JFR Demo 

[col3-lc]
--
video::../images/jfr.mp4[jfr-screen.png, height=720,options=nocontrols,background-color="white"]
--

[col3-r.left.small]
--
**Flight Recorder Demo**

.Prozess identifizieren
  jcmd

.Recording
  jcmd <pid> JFR.start
  jcmd <pid> JFR.dump \
    filename=record.jfr

[.xx-small.decent]
Optionen: `filename`, `delay`, `dumponexit`, `duration`, `maxage`, `maxsize`, …


.Analysieren
  jfr print record.jfr 
  jfr print \
     --events CPULoad \
     --json record.jfr
  jfr summary record.jfr



--




[%notitle,background-video="jmc.mp4",background-video-loop="false",background-size="contain"]
=== JDK Mission Control (JMC)
[.refs.xx-small]
--
https://openjdk.java.net/projects/jmc/8/
--

=== JFR Event Streaming [jep]#https://openjdk.java.net/jeps/349[JEP 349]#

[%notitle,transition="fade-out",background-image="jfrstreaming0.png",background-size="contain"]
=== JDK11
[.notes]
--
* Vor JDK14: Start JFR → Dump (File/JMX) → Analyze.
* Gut für Profiling, schlecht für Continuous Monitoring
--

[%notitle,transition="fade-out",background-image="jfrstreaming1.png",background-size="contain"]
=== JDK14
[.notes]
--
* Mit Java 14: JFR Event Streaming:
* API anbieten um (kontinuierlich) Events des JFR Disk Repo lesen zu können
* Ziel: Trivial kontinuierlich JFR Events monitoren und darauf reagieren können
--

[%notitle,transition="fade-out",background-image="jfrstreaming2.png",background-size="contain"]
=== JDK16
[.notes]
--
* JDK 16: Erlaubt auch Remote Streaming
* JDK16: Neues, leichtgewichterges `jdk.ObjectAllocationSample` **default on**
* GraalVM ab 21.2 unterstützt ebenfalls JFR
--

=== JFR Event Streaming API: Beispiel

Reported sekündlich CPU Usage und aktive Locks länger als 10ms:

[source,java]
----
try (var rs = new RecordingStream()) {
  rs.enable("jdk.CPULoad").withPeriod(Duration.ofSeconds(1));
  rs.enable("jdk.JavaMonitorEnter").withThreshold(Duration.ofMillis(10));

  rs.onEvent("jdk.CPULoad", event -> {
    System.out.println(event.getFloat("machineTotal"));
  });
  rs.onEvent("jdk.JavaMonitorEnter", event -> {
    System.out.println(event.getClass("monitorClass"));
  });

  rs.start(); // Blockierender Aufruf, bis Stream endet/geschlossen wird
  // rs.startAsync(); Alternative im separaten Thread
}
----


[.small]
=== Streaming API: Möglichkeiten

[source.col2.fragment,java]
.Passiv, eigener Prozess
----
EventStream.openRepository()) {…}
----

[source.col2.fragment,java]
.Passiv, fremder Prozess
----
EventStream.openRepository(Path.of("…")))
----

[source.fragment,java]
.Aktiv, eigener Prozess
----
try (var stream = new RecordingStream()) { … }
----


[source.fragment,java]
.Aktiv, fremder Prozess (Remote)
----
String url = "service:jmx:rmi:///jndi/rmi://myhost.de:7091/jmxrmi";
JMXConnector c = JMXConnectorFactory.connect(new JMXServiceURL(url));
MBeanServerConnection conn = c.getMBeanServerConnection();

try (RemoteRecordingStream stream = new RemoteRecordingStream(conn)) { … }
----



[.small.degrade]
=== Eigene JFR Events

[col2]
--
[source,java]
.Event definieren
----
import jdk.jfr.*;

@Name("de.bentolor.ButtonPressed")
@Label("Button Pressed")
@StackTrace(false)
public class ButtonEvent extends Event {
    @Label("Button name")
    public String name;

    @Label("Source")
    public String trigger;

    @Label("Number of Bounces")
    @DataAmount
    public int bounces;

    @Label("Has timeouted")
    public boolean timeouted;
}
----
--
[col2]
--
.Event füttern & auslösen
[source,java]
----
ButtonEvent evt = new ButtonEvent();
if(evt.isEnabled()) {
    evt.name = "Button 1";
    evt.trigger = "Keyboard";
    evt.begin();
}

// doSomething()

if(evt.isEnabled()) {
    evt.end();
    evt.timeouted = false;
    evt.bounces = 3;
    evt.commit();
}
----
--


[.degrade]
=== Weitere Anwendungsfälle

[.small.col2]
Unit- & Performance-Testing::
Annahmen zum Verhalten von API, JVM & Co. in Testcases sichern. +
 +
[decent]#Unterstützende Frameworks z.B. https://github.com/moditect/jfrunit[JfrUnit] oder https://github.com/quick-perf/quickperf[QuickPerf]#


[.small.col2]
Timeshift-Analyse::
Recording mitlaufen lassen und bei Performance-Problemen rückwirkend seit Problemstartpunkt aus dem JFR Event Repository extrahieren & analysieren (_„Timeshift“_)




== JVM Diagnostics

* `-XX:+ExtensiveErrorReports` → ausführlichere Crash-Reports in `hs_err<pid>.log`
* Asynchrones _Unified JVM Logging_ erzwingen`-Xlog:async` und `-XX:AsyncLogBufferSize=<bytes>` über separaten Thread

[.notes]
--
* To avoid undesirable delays in a thread using unified JVM logging, you now can request that the unified logging system operate in asynchronous mode by using the -Xlog:async command-line option. In asynchronous logging mode, all logging messages are queued to a buffer, and a standalone thread is responsible for flushing them to the corresponding outputs. The intermediate buffer is bounded; on buffer exhaustion, the enqueuing message is discarded. 
--

== Misc

=== Bessere Nullpointers [jep]#https://openjdk.java.net/jeps/358[JEP 358]#

[source,java]
----
class MyClass {
    record Person(String name, String email) {}
    public static void main(String[] args) {
        var p = new Person("Peter", null);                                 <1>
        var e = p.email().toLowerCase();
    }
}
----

[source,text,subs="none"]
----
$ java MyClass.java
Exception in thread "main" java.lang.NullPointerException: Cannot invoke <mark>"String.toLowerCase()</mark> because the return value of <mark>"MyClass$Person.email()" is null</mark>
        at MyClass.main(MyClass.java:5)
----

<1> Für Namen von _lokalen Variablen_ und _Lambdas_ mit `-g:vars` compilieren!


[.notes]
--
* Erforderte früher `-XX:+ShowCodeDetailsInExceptionMessages`, nun default!
--

=== Preview features [preview]#Preview# [jep]#https://openjdk.java.net/jeps/12[JEP 12]#
Auslieferung experimenteller Sprach- und JVM-Features, +
oft in Iterationen, zur Förderung von frühem Community Feedback. +
[.decent.x-small]#_z.B.: Pattern Matching, Switch Expression, Text Blocks, Records, Sealed Classes_#

[.col2]
--
[source,bash]
.Unlock Compilation
----
javac --enable-preview …
----
--
[.col2]
--
[source,bash]
.Unlock Execution
----
java --enable-preview …
----
--
[.clear]
--
{sp} +
[.decent.small]#Keine Cross-compilation mittels `--release xx` möglich!#
--
[.notes]
--
* Forces awareness by using toggle switch on _compiling and running_
* Typisch mehrere Iterationen (z.B. `switch`-Statement)
* Stabilisierung auf LTS; in 17 LTS daher kein Preview Feature
--

=== Incubator Modules [preview]#Incubator# [jep]#https://openjdk.java.net/jeps/11[JEP 11]#
Analog _Preview Features_ für nicht-finale APIs und Tools +

[source,bash]
----
javac --add-modules jdk.incubator.foo …
java  --add-modules jdk.incubator.foo …
----

[.decent.x-small]#_z.B.: HTTP/2 Client, Packaging Tool, …_#
// Vector API, Foreign Function & Memory API


[.notes]
--
Interessanterweise 2 "Incubator" in der LTS Version: _"Vector API"_ und _"Foreign Function & Memory API"_
--

== Foreign Function & Memory API [preview]#Incubator# 
// [jep]#https://openjdk.java.net/jeps/412[JEP 412]#

=== Retro: Java Native Interface (JNI)

image::jni-process.png[Java Native Interface Process, 800, float="left"]
[.small]
--
* 26 Jahre alt
* erfordert `.c` & `.h`-Files
* mehrstufiger Prozess: +
  kleinteilig & brüchig
  
↓

sehr verworren

--
[.notes]
--
bildquelle: https://developers.redhat.com/blog/2016/11/03/eclipse-for-jni-development-and-debugging-on-linux-java-and-c#general_overview_of_jni_compilation_and_the_eclipse_project
--

=== Motivation Project Panama [preview]#Incubator# [jep]#https://openjdk.java.net/jeps/412[JEP 412]#

Starke Drittbibliotheken (z.B. ML/AI) mit dynamischer Entwicklung +
[decent]#_Tensorflow_, _OpenSSL_, _libodium_, …#

[.x-small.fragment.tgap]
> Introduce an API by which Java programs can interoperate with code and 
data outside of the Java runtime […] without the brittleness and danger of JNI.

[.fragment.tgap]
**Ziele:** _Einfachheit – Performance – Sicherheit_

//  https://www.youtube.com/watch?v=B8k9QGvPxC0
[.notes]
--
* Motivation: ML → Python Ecosystem → vs. re-implementing

* Ziele
** Einfachheit → nur Java → hofft auf Tooling
** Performance: Vergleichbar mit JNI
** Sicherheit:  Disable unsafe operations by default; Abkommen von `sun.misc.Unsafe`; 

* Abkehr von `unsafe` oder ByteBuffer mit ihren Limits, wie z.B. ByteBuffer max. 2GB und GC-managed.

* Historie: 
** Zwei JEPs / APIs: Memory Access API & Foreign Linker API
** erstmals JDK14, dann 15, 16 und nun zusammengeführt in 17
--

[.degrade]
=== Einfacher Funktionsaufruf

[source,java]
----
import java.lang.invoke.*;
import jdk.incubator.foreign.*;

class CallPid {
  public static void main(String... p) throws Throwable {
    var libSymbol = CLinker.systemLookup().lookup("getpid").get();      <1>
    var javaSig = MethodType.methodType(long.class);                    <2>
    var nativeSig = FunctionDescriptor.of(CLinker.C_LONG);              <3>

    CLinker cABI = CLinker.getInstance();
    var getpid = cABI.downcallHandle(libSymbol, javaSig, nativeSig);

    System.out.println((long) getpid.invokeExact());  
  }
}
----
<1> adressiertes _Symbol_ – hier via Lookup in den System Libraries
<2> gewünschte _Java-Signatur_ des Java Foreign Handles
<3> _Ziel-Signatur_ der aufzurufenden C-Funktion

[.degrade]
=== Aufruf mit Pointer (1/2)
[source,c]
----
int crypto_box_seal(unsigned char *c, const unsigned char *m,
                    unsigned long long mlen, const unsigned char *pk)
----
[.decent.xx-small]#…liest Text aus `*m` und schreibt 
verschlüsseltes Ergebnis nach `*c`# +
↓
[source.fragment,java]
----
var cryptoBoxSeal = CLinker.getInstance().downcallHandle(
        SymbolLookup.loaderLookup().lookup("crypto_box_seal").get(),
        MethodType.methodType(int.class,
                              MemoryAddress.class, MemoryAddress.class,
                              long.class, MemoryAddress.class),
        FunctionDescriptor.of(C_INT,
                              C_POINTER,   C_POINTER,
                              C_LONG_LONG, C_POINTER) );
----




[.small.degrade]
=== Aufruf mit Pointer (2/2)

.Foreign Heap wird vom GC via `ResourceScope` verwaltet
[source,java]
----
try (var scope = ResourceScope.newConfinedScope()) { … }
----

[.fragment]
.String-Konvertierung & Kopie in nativen Heap
[source,java]
----
var plainMsg = CLinker.toCString("abc", scope);
----

[.fragment]
.Reservierung Ziel-Speicherbereich
[source,java]
----
var cipherText = scope.allocate(48 + plainMsg.byteSize(), scope);
var pubKey = scope.allocateArray(C_CHAR, publicKey);
----

[.fragment]
.Aufruf & Rückgabe
[source,java]
----
var ret = (int) cryptoBoxSeal.invokeExact(
            cipherText.address(), plainMsg.address(), 
            (long) plainMsg.byteSize(), pubKey.address());
return cipherText.toByteArray();
----



=== Helferlein `jextract`

Generiert einen API Wrapper als `.class` oder `.java` +
direkt aus `.h`-Dateien mit den notwendigen Foreign API-Aufrufen. +
[.decent.xx-small]#Nicht in JDK 17 direkt enthalten; sondern via Panama EAP JDK Builds.#

[.fragment]
--
[source,shell]
----
$ jextract -t de.bentolor /usr/include/unistd.h
----

[source,java]
----
import de.bentolor.unistd_h;

class CallPid {
   public static void main(String[] args) {
      System.out.println( unistd_h.getpid() );
      System.out.println( ProcessHandle.current().pid() );
  }
}
----
--



[.refs.x-small]
--
https://jdk.java.net/panama/[Project Panama Early-Access Builds]
--




[.lightbg,background-video="hammer.mp4",background-video-loop="true",background-opacity="0.7"]
== Tooling

=== jdeps
=== javadoc (+Demo?)

=== Packaging Tool `jdk.jpackage` [jep]#https://openjdk.java.net/jeps/343[JEP 343]# [jep]#https://openjdk.java.net/jeps/392[JEP 392]#

* Create a tool for packaging self-contained Java applications.
* Supports native packaging formats to give end users a natural installation experience. These formats include msi and exe on Windows, pkg and dmg on macOS, and deb and rpm on Linux.
* Allows launch-time parameters to be specified at packaging time.
* Non-Goals
** There is no native splash screen support.
** There is no auto-update mechanism.
[.notes]
--
* Preview mit JDK14, stabilisiert mit JDK16
--



[%notitle,background-video="jpackagerfast.mp4",background-size="contain",background-color="black"]
=== Installation packages with `jpackager` [jep]#https://openjdk.java.net/jeps/343[JEP 343]# [jep]#https://openjdk.java.net/jeps/392[JEP 392]#



== Details & Maintenance

=== Strongly Encapsulate JDK Internals by Default 
* JEP 411 (JDK 17): The Security Manager was deprecated for removal
* https://openjdk.java.net/jeps/306 JEP 306 (JDK 17): Always-strict floating-point semantics have been restored


[.notes]
--
* Java currently supports two different models for floating-point operations. One is the strict floating-point semantics, which are supported by AMD and Intel microprocessors. However, Java’s default is a slightly different floating-point semantics scheme. This split occurred back in Java SE 1.2, when there were some issues with the x87 math coprocessor. It’s no longer needed because all of today’s processors support SSE2 (Streaming SIMD Extensions 2) and later extensions in a way that eliminates the need for the default semantics. Therefore JEP 306’s intention is to make floating-point operations consistently strict by restoring the original floating-point semantics to the language and JVM.
--


=== Plattform 
.Architekturen
* JEP 391: macOS/AArch64 Port

.Unicode
* x

=== Kryptographie
* Cipher Streams & Signatures


== Fazit


[%notitle, background-image="tweet-jdk-evolving.png"]
=== Bottom line
TODO



[.lightbg,background-video="industrial.mp4",background-video-loop="true",background-opacity="0.6"]
=== Ressourcen

[.col3-l.xx-small]
--
.Referenzwerke
* xx
* https://chriswhocodes.com/vm-options-explorer.html[VM Options Explorer]
* https://docs.oracle.com/en/java/javase/17/gctuning/available-collectors.html[HotSpot Tuning Guide: Available Collectors]

.Artikel
* https://blog.arkey.fr/2021/09/04/a-practical-look-at-jep-412-in-jdk17-with-libsodium/[A practical look at JEP-412]
* https://docs.oracle.com/en/java/javase/14/vm/class-data-sharing.html[Application Class-Data Sharing]
* http://www.oracle.com/pls/topic/lookup?ctx=javase14&id=dynamic_CDS_archive[Dynamic CDS Archive]
* https://blogs.oracle.com/javamagazine/understanding-the-jdks-new-superfast-garbage-collectors[Understanding the JDK’s New Superfast Garbage Collectors]

.Tools
* http://jdk.java.net/jmc/[JDK Mission Control]

.Weiterführendes
* https://www.youtube.com/watch?v=B8k9QGvPxC0[State of Project Panama]


.Tools
* https://www.graalvm.org/[GraalVM]
* https://openjdk.java.net/projects/jmc/8/[JDK Flight Mission Control 8]
* https://chriswhocodes.com/hotspot_options_openjdk17.html[VM Options Explorer ]
--


[.col3-c.xx-small]
--
.Contact
* Twitter https://twitter.com/bentolor[*@bentolor*]
* Email: mailto:ben@tolor.de[]

.Sources
* icon:code-branch[Github] https://github.com/bentolor/java9to13[*GitHub Repo with Source Code Examples & Slide Sources*]
* https://de.freeimages.com/photographer/s_lim363-49742[Background image],
  https://www.pexels.com/video/a-bee-on-a-yellow-flower-2048452/[Flowers], https://www.pexels.com/video/relaxing-at-the-beach-1449880/[Relaxing at the beach], https://www.pexels.com/video/cup-of-coffee-on-top-of-coffee-beans-855414/[Coffee Beans], https://www.pexels.com/video/close-up-video-of-a-woman-studying-855418/[Woman studying], https://www.pexels.com/video/white-keyboard-2219383/[White keyboard], https://www.pexels.com/video/jack-hammering-pavement-855956/[Jackhammer], https://www.pexels.com/video/globe-plasma-light-1192113/[Plasma Light], https://www.pexels.com/video/heavy-equipment-loading-cement-2073130/[Industrial Site]
--

[.col3-r.small]
--
* xxx
--

[pass]
++++
<script src="./live.js"></script>
++++

//include::presentation-intro.adoc[] 
//include::presentation-agenda.adoc[] 
//include::presentation-highlights.adoc[] 
//include::presentation-language.adoc[] 
//include::presentation-api.adoc[] 
//include::presentation-tooling.adoc[]
//include::presentation-outlook.adoc[]
//include::presentation-appendix.adoc[]
