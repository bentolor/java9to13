= Unter der Haube: Deep Dive 4 – Die wichtigsten Neuerungen seit Java 11
:author: Benjamin Schmid @bentolor <ben@tolor.de>
:date: 2021-09-14
:icons: font
// we want local served fonts. Therefore patched sky.css
//:revealjs_theme: sky
:revealjs_customtheme: css/sky.css
//:revealjs_autoSlide: 5000
:revealjs_history: true
:revealjs_fragmentInURL: true
:revealjs_viewDistance: 5
:revealjs_width: 1408
:revealjs_height: 792
:revealjs_controls: false
:revealjs_controlsLayout: edges
:revealjs_controlsTutorial: true
:revealjs_slideNumber: c/t
:revealjs_showSlideNumber: speaker
:revealjs_autoPlayMedia: true
:revealjs_defaultTiming: 42
//:revealjs_transitionSpeed: fast
//:revealjs_parallaxBackgroundImage: images/background-landscape-light-orange.jpg
//:revealjs_parallaxBackgroundSize: 4936px 2092px
:revealjs_parallaxBackgroundImage: images/what-s-under-the-hood-1560145-light.jpg
:revealjs_parallaxBackgroundSize: 5000px 3376px
:customcss: css/presentation.css
:imagesdir: images
:source-highlighter: highlightjs
:highlightjs-theme: css/atom-one-light.css
// we want local served font-awesome fonts
:iconfont-remote!:
:iconfont-name: fonts/fontawesome/css/all



// [.lightbg, background-image="327-chevy-engine-1542516.jpg",background-opacity="0.9"]
== 3 Motor-Upgrades
[decent]#… auf die ich mich in Java 17 freue#

[.lightbg.forcebottom,background-video="time-passes-by-so-quickly.mp4",background-video-loop="true",background-opacity="1"]
=== Mehr _Schwuppidizität_
[.notes]
--
… durch _niedriglatente GCs_ und schnellere JVM Start zur _Class-Data Sharing_
--


[.lightbg.forcebottom,background-video="pexels-cottonbro-9293441.mp4",background-video-loop="true",background-opacity="1"]
=== Mehr Durchblick


[.lightbg.forcetop,background-video="pexels-koolshooters-7327408.mp4",background-video-loop="true",background-opacity="1"]
=== Mehr Hilfestellung
[.notes]
--
… z.B. durch _sprechende Nullpointer-Exceptions_ und bessere JVM Defaults
--




// [.lightbg,background-video="coffee-beans.mp4",background-video-loop="true",background-opacity="0.7"]
// == Java 12--17 in a nutshell

// === v9 (huge…)
// * *Java module (Jigsaw)*
// * *API Improvements:* _Project Coin Milling_, Stream, … 
// * *Unified JVM & Java Logging*, …
// //  Reflection, Date, Concurrency, …
// // * _Deprecated:_ `finalize()` 
// * *Performance*
// * _Tools:_ `jshell` `jlink` `-release`, Multi-Release JARs
// //* _New platforms:_ *AArch64, s390x, Arm32/Arm64*

// [decent]#2017-03-23, icon:exclamation-circle[] http://openjdk.java.net/projects/jdk9/[*91* JEPs]#

// === Recap
// > Auch Blick unter die Haube lohnt sich; manche transaprent & für alle; manche muss man sich erschließen
// [.notes]
// --
// * Viele Änderungen unter der Haube
// * Einige auch nicht so präsent, z.B. Shennandoah GC
// * Blick unter die "Haube", also JVM, Tools und JVM Internals
// --


[.lightbg,background-video="relaxing.mp4",background-video-loop="true",background-opacity="0.7"]
== Agenda
1. Native
// Vector API
//** Native Memory/Function
2. Diagnostik
//** JFR / JMC
3. Memory Management
4. Tools
5. Details & Maintenance


// == Vector API
// https://openjdk.java.net/jeps/414

// [.notes]
// --
// ntegrated into JDK 16 as an incubating API, the platform-agnostic vector API will be incubated again in JDK 17, providing a mechanism to express vector computations that reliably compile at run time to optimal vector instructions on supported CPU architectures. This achieves better performance than equivalent scalar computations. In JDK 17, the vector API has been enhanced for performance and implementation, including enhancements to translate byte vectors to and from boolean arrays.
// --




== Garbage Collectoren

[.degrade.x-small]
=== Timeline
[width=60%,grid=vertical,frame=none,cols="^1e,5"]
|===
|11 | [decent]#icon:vial[]# ZGC Experimental
|12 | [decent]#icon:vial[]# Shenandoah Experimental +
      [decent]#icon:compress-alt[] G1 Uncommit Memory# +
      [decent]#icon:undo[] ZGC Class Unloading#
|13 | [decent]#icon:compress-alt[] ZGC Uncommit Memory# 
|14 | icon:windows[] & icon:apple[] ZGC Support +
      icon:trash[] CMS Removal +
      [decent]#icon:bomb[] ParalellOldGC Deprecation#       
|15 | icon:award[] **Shenandoah** Production-ready +
      icon:award[] **ZGC** Production-ready
|16 | [decent]#icon:chart-line[] ZGC Improvements#
|===



=== Die neue Generation der Low-Latency GCs

// .Gemeinsamkeiten ZGC & Shennadoah
* Moderne Architekturen: _Multi-Core_ & _TB RAM_
* _kurze GC Pausen_ im ms-Bereich +
  → erkauft **Responsiveness** gegen _Durchsatz_
* (fast) vollständig _parallel & nebenläufig_ +
  Pausen unabhängig von Größe des Heaps
* Unterstützen _Class Unloading_ & _Uncommit Memory_
* Einfach & Konfigurationsarm 

[.notes]
--
* _Multi-Core_ & _TB RAM_
* Ziel ist immer **niedrige Latenz**
* bei G1 & Co gerne mal 200~500ms; hier: 1-10ms;
* Schnellere Reaktion geringere Gesamtdurchsatz & Damit längere Laufzeit
--



=== Z Garbage Collector (ZGC)

[col2]
--
image:in_place_relocation2.svg[width=600,role=plain]

`-XX:+UseZGC`
--

[col2.small]
--
_„A scalable low-latency garbage collector“_

.Ziele
* GC Pausen kleiner [deleted]#10ms# **1ms**
* Durchsatz max. -15% gegenüber G1
* Heapgrößen  8MB – **16TB**
* Einfaches Tuning

[emphasize]#_Colored Pointers & Load Barriers_ + 
→ Object Relocation#
--

[.refs]
--
https://wiki.openjdk.java.net/display/zgc/Main
--

[.notes]
--
* Aus dem Hause _Oracle_; ehemals kommerziell
* Pausen auch unabhängig Live- & Root-Set
* Production since JDK 15; dann auch mit Linux/Win/macOS
* Nebenläufig, Regionen-basiert, ohne Generation, _Compacting_ und _NUMA-aware_
* Konzept: _Colored pointers_ plus _Load barriers_ → Relocation
* "Schwuppizität" zum Preis von CPU und Gesamtlaufzeit
--  

[.left]
=== Shennadoah GC

_„A low-pause-time garbage collector by concurrent evacuation work“_ +

[col2.small]
--
* ZGC sehr ähnlich _Brooks (Forward) Pointers_ 

* Bietet verschieden Modi & Heuristic-Profile: 
  _adaptive, static, compact, aggressive_

* Beil zahlreichen Weak References → ZGC

--

[col2.small]
--
* **Red Hat** Kind → andere Service Offerings

* **Backports** für JDK 8 & 11; auch **32-bit**

* ggü. ZGC: abhängig von Root- & Live-Set
 
[x-small]#`-XX:+UseShenandoahGC`#
--

[.center]

image:shenandoah-gc-cycle.png[role=plain, width=1000]


[.refs]
--
https://wiki.openjdk.java.net/display/shenandoah
--

[.notes]
--
* Name nach US Nationalpark
* von Red Hat → auch Backports & Architekturen (z.B. ARM32)
* seit 2013 und seit v12 im JDK; seit JDK15 Production
* Pausen steigen mit Root Set / Live Set
--




[%notitle,background-image="gc-performance-transparent.png",background-size="contain"]
=== Performance G1 vs. ZGC vs. Shenandoah
[.notes]
--
* Arbeitsbereich ist links! Rechts = Überlast
* S & Z : Vergleichbare, gegenüber G1 deutlich niederige Latenzen
* Verhalten bei wachsender Last: Hier scheint ZGC irgendwann den Punkt zu erreichen wo es nicht mehr mithalten kann; bei Shenandoah früher Latenz
* Man sieht klar: G1 ist Tradeoff zwischen Latenz & Durchsatz → auch bei höhere Durchsatz stabil
--










[.degrade]
=== GC in der Übersicht

[.x-small,cols=">1e,^2,7",grid="horizontal",frame="none"]
|===
|GC | Optimiert für… | Kommentar

| G1
| Balance
| Üblicher Default. Überwiegend Nebenläufig. Zielt auf Balance von Durchsatz & Latenz. Außreißer-Pausen bis 250~800ms. Guter Durchsatz. Häppchenweise Pausen an Zeitbudget orientiert.

| Shenandoah
| Latenz
| Auch verfügbar für JDK8, JDK11 und 32-bit.

| ZGC
| Latenz
| besser für `WeakRef`; Pausen auch unabhängig Live- und Root-Set

| ParallelGC
| Durchsatz
| Parallel & mehrere Threads. Hoher Durchsatz. +
  Typische Pausen ~300ms abhängig von Heap-Größe.

| SerialGC
| Speicherbedarf
| Single-Threaded. Empfiehlt sich nur für Heaps ~100MB.

| Zing/Azul
| Pauseless
| Nicht im OpenJDK; nur kommerziell verfügbar

|===




[.degrade]
=== Überblick Änderungen GC's

[col3-c.x-small]
--
.ZGC
* Concurrent Class Unloading [version]#12#
* Uncommit Unused Memory [jep]#https://openjdk.java.net/jeps/351[JEP 351]# [version]#13#
* `-XXSoftMaxHeapSize` Flag [version]#13#
* Max. Heap Size Increased to 16TB [version]#13#
* ZGC on macOS [jep]#https://openjdk.java.net/jeps/364[JEP 364]# [version]#14# 
* ZGC on Windows [jep]#https://openjdk.java.net/jeps/365[JEP 365]# [version]#14# 
* ZGC Production-Ready [jep]#https://openjdk.java.net/jeps/377[JEP 377]# [version]#15#
* Concurrent Stack Processing [jep]#https://openjdk.java.net/jeps/376[JEP 376]# [version]#16#

.Epsilon
* Epsilon Bug TLABs extension [version]#14#
* Epsilon warns about Xms/Xmx/… [version]#14#
--
[col3-l.x-small]
--

.G1
* [.step.highlight-current-blue]#OldGen on NV-DIMM# [version]#12#
* [.step.highlight-current-blue]#Uncommit Memory# [version]#12#
* Improved Sparse PRT Ergonomics [version]#13#
* NUMA-Aware Memory Alloc. [jep]#https://openjdk.java.net/jeps/354[JEP 354]# [version]#14#
* Improved Heap Region Ergonomics [version]#15#
* Concurrently Uncommit Memory [version]#16#

.Shenandoah
* Shenandoah (Experimental)  [jep]#https://openjdk.java.net/jeps/189[JEP 189]# [version]#12#
* Self-fixing barriers [version]#14#
* Async. object/region pinning [version]#14#
* Concurrent class unloading [version]#14#
* Arraycopy improvements [version]#14#
* Shenandoah Production-Ready [jep]#https://openjdk.java.net/jeps/379[JEP 379]# [version]#15#

--
[col3-r.x-small]
--

.Bugfixes
* Disable large pages on Windows [version]#15#
* Disable NUMA Interleaving on Win.[version]#15#


.Legacy
* [.step.highlight-current-red]#ParallelGC Improvements# [version]#14#
* Obsolete [x-small]#`-XXUseAdaptiveGCBoundary`# [version]#15#
* Enable Parallel Ref. Processing [version]#17#
* SerialGC Improved young report [version]#13#
* ParalellOldGC: Deprecate [jep]#https://openjdk.java.net/jeps/366[JEP 366]# [version]#14#
* [.step.highlight-current-red]#CMS: Remove CMS GC# [jep]#https://openjdk.java.net/jeps/363[JEP 363]# [version]#14#

[.step.highlight-current-red]#icon:exclamation-triangle[] Many, many, more…#
--

[.notes]
--
. Old Gen auf alternativen Memory Geräten
. G1 kann wieder Speicher freigeben
. Auch ParallelGC erfährt Verbesserungen
. CMS wurde entfernt
. → Viel mehr; teils nicht in den Release Notes
--


=== TL;DR Tipps für den GC

[%step]
Upgrade lohnt sich!

[%step]
Probieren geht über Studieren!

[%step]
Mut zum (probeweisen) Wegwerfen: +
Alte Tuning-Parameter

[%step]
Latenz wichtig? → ZGC oder Shenandoah


[.refs]
--
https://blogs.oracle.com/javamagazine/understanding-the-jdks-new-superfast-garbage-collectors
https://docs.oracle.com/en/java/javase/17/gctuning/available-collectors.html
--








== Class Data Sharing 


=== Class Data-Sharing in a Nutshell

Class Data-Sharing::
[emphasize]#Reduziert Startzeiten & Speicherbedarf# von JVMs durch `.jsa` Archiv mit Metadaten der Klassen.
+
→ Klassen liegen damit vorgeparsed in _direkt für die JVM verwendbarem_ Format vor. Das Archiv kann _read-only_ eingebunden werden, was dem OS _Caching_ & _Sharing_ erlaubt.
+
**Achtung:** Archive sind JVM Plattform- und Versionspezifisch!

Application Class-Data Sharing (AppCDS)::
Erlaubt zusätzlich Applikations-Klassen in das CDS aufzunehmen

=== Neuerungen im Bereich CDS

Default CDS Archive [version]#12# [jep]#https://openjdk.java.net/jeps/341[JEP 341]#::
JVM liefert nun per Default ein `classes.jsa` CDS-Archiv mit aus, welches ein Subset der häufigsten JDK-Klassen umfasst.

Dynamic CDS Archive [version]#13# [jep]#https://openjdk.java.net/jeps/350[JEP 350]#::
Vereinfacht erheblich die Erstellung eigener AppCDS Archive durch automatische Auswahl und Archiverzeugung beim beenden der Java-Applikation.


=== AppCDS Archiverstellung

.Erstellung über Liste [version]#11#
[source,shell]
----
$ java -Xshare:off -XX:DumpLoadedClassList=myclasses.txt -cp myapp.jar MyApp

$ java -Xshare:dump -XX:SharedArchiveFile=myapp.jsa \
       -XX:SharedClassListFile=myclasses.txt -cp myapp.jar
----

[.fragment]
.Nutzung des AppCDS-Archives
[source,shell]
----
$ java -XX:SharedArchiveFile=myapp.jsa -cp myapp.jar MyApp
----

[.fragment]
.NEU: Automatische Erstellung [version]#13#
[source,shell]
----
$ java -XX:ArchiveClassesAtExit=myapp.jsa -cp myapp.jar MyApp
----


[%notitle]
=== AppCDS Gewinne
image::app_cds_time_to_first_response.png[AppCDS Startup Times,height=700]
[.refs]
--
Quelle: https://www.morling.dev/blog/building-class-data-sharing-archives-with-apache-maven/
--
[.notes]
--
* Teils bis zu 40% Reduktion in Startup-Times
* Noch mehr Potential mit Kombination von `jlink`
* Quelle hier: Gunnar Morling
--




== JDK Flight Recorder (JFR)

=== JDK Flight Recorder (JFR) [jep]#https://openjdk.java.net/jeps/328[JEP 328]#
* OS, JVM, JDK & App Diagnostik
* extrem geringer Overhead (~1%)
* built-in & jederzeit aktivierbar
* always-on möglich → Timemachine

→ [.step.highlight-current-red]#icon:cogs[] **Production** Profiling & Monitoring#

[.decent.x-small]


[.notes]
--
* Ehemals kommerzielles JVM Addon "Java Flight Recorder" 
* seit Java 11 OpenJDK Bestandteil 
* Aktivierbar für neue und *bereits laufende* Java-Instanzen
* Zielmetrik: Weniger als 1% Overhead → no measurable impact on the running application →  klare Ausrichtung für Produktionsverwendung
* Built by the JVM/JDK people 
** → access to data already collected, more accurate, faster
** Safe and reliable in production 
* always on  →  Time machine – just dump the recording data when a problem occurs, and see what the runtime was up to before, up to, and right after the problem occurred.
* Even on JVM crash → JFR data avail in dump

JDK Mission Control also contains other tools, such as a JMX Console, and HPROF-dump analyzer and more.
--




[%notitle]
=== JFR Demo 

[col3-lc]
--
video::../images/jfr.mp4[jfr-screen.png, height=720,options=nocontrols,background-color="white"]
--

[col3-r.left.small]
--
**Flight Recorder Demo**

.Prozess identifizieren
  jcmd

.Recording
  jcmd <pid> JFR.start
  jcmd <pid> JFR.dump \
    filename=record.jfr

[.xx-small.decent]
Optionen: `filename`, `delay`, `dumponexit`, `duration`, `maxage`, `maxsize`, …


.Analysieren
  jfr print record.jfr 
  jfr print \
     --events CPULoad \
     --json record.jfr
  jfr summary record.jfr



--




[%notitle,background-video="jmc.mp4",background-video-loop="false",background-size="contain"]
=== JDK Mission Control (JMC)
[.refs]
--
https://openjdk.java.net/projects/jmc/8/
--

=== JFR Event Streaming [jep]#https://openjdk.java.net/jeps/349[JEP 349]#

[%notitle,transition="fade-out",background-image="jfrstreaming0.png",background-size="contain"]
=== JDK11
[.notes]
--
* Vor JDK14: Start JFR → Dump (File/JMX) → Analyze.
* Gut für Profiling, schlecht für Continuous Monitoring
--

[%notitle,transition="fade-out",background-image="jfrstreaming1.png",background-size="contain"]
=== JDK14
[.notes]
--
* Mit Java 14: JFR Event Streaming:
* API anbieten um (kontinuierlich) Events des JFR Disk Repo lesen zu können
* Ziel: Trivial kontinuierlich JFR Events monitoren und darauf reagieren können
--

[%notitle,transition="fade-out",background-image="jfrstreaming2.png",background-size="contain"]
=== JDK16
[.notes]
--
* JDK 16: Erlaubt auch Remote Streaming
* JDK16: Neues, leichtgewichterges `jdk.ObjectAllocationSample` **default on**
* GraalVM ab 21.2 unterstützt ebenfalls JFR
--

=== JFR Event Streaming API: Beispiel

Reported sekündlich CPU Usage und aktive Locks länger als 10ms:

[source,java]
----
try (var rs = new RecordingStream()) {
  rs.enable("jdk.CPULoad").withPeriod(Duration.ofSeconds(1));
  rs.enable("jdk.JavaMonitorEnter").withThreshold(Duration.ofMillis(10));

  rs.onEvent("jdk.CPULoad", event -> {
    System.out.println(event.getFloat("machineTotal"));
  });
  rs.onEvent("jdk.JavaMonitorEnter", event -> {
    System.out.println(event.getClass("monitorClass"));
  });

  rs.start(); // Blockierender Aufruf, bis Stream endet/geschlossen wird
  // rs.startAsync(); Alternative im separaten Thread
}
----


[.small]
=== Streaming API: Möglichkeiten

[source.col2.fragment,java]
.Passiv, eigener Prozess
----
EventStream.openRepository()) {…}
----

[source.col2.fragment,java]
.Passiv, fremder Prozess
----
EventStream.openRepository(Path.of("…")))
----

[source.fragment,java]
.Aktiv, eigener Prozess
----
try (var stream = new RecordingStream()) { … }
----


[source.fragment,java]
.Aktiv, fremder Prozess (Remote)
----
String url = "service:jmx:rmi:///jndi/rmi://myhost.de:7091/jmxrmi";
JMXConnector c = JMXConnectorFactory.connect(new JMXServiceURL(url));
MBeanServerConnection conn = c.getMBeanServerConnection();

try (RemoteRecordingStream stream = new RemoteRecordingStream(conn)) { … }
----



[.small.degrade]
=== Eigene JFR Events

[col2]
--
[source,java]
.Event definieren
----
import jdk.jfr.*;

@Name("de.bentolor.ButtonPressed")
@Label("Button Pressed")
@StackTrace(false)
public class ButtonEvent extends Event {
    @Label("Button name")
    public String name;

    @Label("Source")
    public String trigger;

    @Label("Number of Bounces")
    @DataAmount
    public int bounces;

    @Label("Has timeouted")
    public boolean timeouted;
}
----
--
[col2]
--
.Event füttern & auslösen
[source,java]
----
ButtonEvent evt = new ButtonEvent();
if(evt.isEnabled()) {
    evt.name = "Button 1";
    evt.trigger = "Keyboard";
    evt.begin();
}

// doSomething()

if(evt.isEnabled()) {
    evt.end();
    evt.timeouted = false;
    evt.bounces = 3;
    evt.commit();
}
----
--


[.degrade]
=== Weitere Anwendungsfälle

[.small.col2]
Unit- & Performance-Testing::
Annahmen zum Verhalten von API, JVM & Co. in Testcases sichern. +
 +
[decent]#Unterstützende Frameworks z.B. https://github.com/moditect/jfrunit[JfrUnit] oder https://github.com/quick-perf/quickperf[QuickPerf]#


[.small.col2]
Timeshift-Analyse::
Recording mitlaufen lassen und bei Performance-Problemen rückwirkend seit Problemstartpunkt aus dem JFR Event Repository extrahieren & analysieren (_„Timeshift“_)


== Misc


=== Bessere Nullpointers [jep]#https://openjdk.java.net/jeps/358[JEP 358]#

[source,java]
----
class MyClass {
    record Person(String name, String email) {}
    public static void main(String[] args) {
        var p = new Person("Peter", null);                                 <1>
        var e = p.email().toLowerCase();
    }
}
----

[source,text,subs="none"]
----
$ java MyClass.java
Exception in thread "main" java.lang.NullPointerException: Cannot invoke <mark>"String.toLowerCase()</mark> because the return value of <mark>"MyClass$Person.email()" is null</mark>
        at MyClass.main(MyClass.java:5)
----

<1> Für Namen von _lokalen Variablen_ und _Lambdas_ mit `-g:vars` compilieren!


[.notes]
--
* Erforderte früher `-XX:+ShowCodeDetailsInExceptionMessages`, nun default!
--



=== JVM Diagnostics

* `-XX:+ExtensiveErrorReports` → ausführlichere Crash-Reports in `hs_err<pid>.log`
* Asynchrones _Unified JVM Logging_ erzwingen `-Xlog:async` und `-XX:AsyncLogBufferSize=<bytes>` über separaten Thread

[.notes]
--
* To avoid undesirable delays in a thread using unified JVM logging, you now can request that the unified logging system operate in asynchronous mode by using the -Xlog:async command-line option. In asynchronous logging mode, all logging messages are queued to a buffer, and a standalone thread is responsible for flushing them to the corresponding outputs. The intermediate buffer is bounded; on buffer exhaustion, the enqueuing message is discarded. 
--



== Foreign Function & Memory API [preview]#Incubator# 
// [jep]#https://openjdk.java.net/jeps/412[JEP 412]#



[.degrade]
=== Exkurs: Preview features [preview]#Preview# [jep]#https://openjdk.java.net/jeps/12[JEP 12]#
Auslieferung experimenteller Sprach- und JVM-Features, +
oft in Iterationen, zur Förderung von frühem Community Feedback. +
[.decent.x-small]#_z.B.: Pattern Matching, Switch Expression, Text Blocks, Records, Sealed Classes_#

[.col2]
--
[source,bash]
.Unlock Compilation
----
javac --enable-preview …
----
--
[.col2]
--
[source,bash]
.Unlock Execution
----
java --enable-preview …
----
--
[.clear]
--
{sp} +
[.decent.small]#Keine Cross-compilation mittels `--release xx` möglich!#
--
[.notes]
--
* Forces awareness by using toggle switch on _compiling and running_
* Typisch mehrere Iterationen (z.B. `switch`-Statement)
* Stabilisierung auf LTS; in 17 LTS daher kein Preview Feature
--


[.degrade]
=== Exkurs: Incubator Modules [preview]#Incubator# [jep]#https://openjdk.java.net/jeps/11[JEP 11]#
Analog _Preview Features_ für nicht-finale APIs und Tools +

[source,bash]
----
javac --add-modules jdk.incubator.foo …
java  --add-modules jdk.incubator.foo …
----

[.decent.x-small]#_z.B.: HTTP/2 Client, Packaging Tool, …_#
// Vector API, Foreign Function & Memory API


[.notes]
--
Interessanterweise 2 "Incubator" in der LTS Version: _"Vector API"_ und _"Foreign Function & Memory API"_
--



[.degrade]
=== Retro: Java Native Interface (JNI)

[.plain]
image::jni-process.png[Java Native Interface Process, 1000, float="left"]

[.small]
--
* 26 Jahre alt
* erfordert `.c` & `.h`-Files
* mehrstufiger Prozess: +
  kleinteilig & brüchig
  
↓

sehr verworren

--
[.notes]
--
bildquelle: https://developers.redhat.com/blog/2016/11/03/eclipse-for-jni-development-and-debugging-on-linux-java-and-c#general_overview_of_jni_compilation_and_the_eclipse_project
--

=== Motivation Project Panama [preview]#Incubator# [jep]#https://openjdk.java.net/jeps/412[JEP 412]#

Starke Drittbibliotheken (z.B. ML/AI) mit dynamischer Entwicklung +
[decent]#_Tensorflow_, _OpenSSL_, _libodium_, …#

[.x-small.fragment.tgap]
> Introduce an API by which Java programs can interoperate with code and 
data outside of the Java runtime […] without the brittleness and danger of JNI.

[.fragment.tgap]
**Ziele:** _Einfachheit – Performance – Sicherheit_

//  https://www.youtube.com/watch?v=B8k9QGvPxC0
[.notes]
--
* Motivation: ML → Python Ecosystem → vs. re-implementing

* Ziele
** Einfachheit → nur Java → hofft auf Tooling
** Performance: Vergleichbar mit JNI
** Sicherheit:  Disable unsafe operations by default; Abkommen von `sun.misc.Unsafe`; 

* Abkehr von `unsafe` oder ByteBuffer mit ihren Limits, wie z.B. ByteBuffer max. 2GB und GC-managed.

* Historie: 
** Zwei JEPs / APIs: Memory Access API & Foreign Linker API
** erstmals JDK14, dann 15, 16 und nun zusammengeführt in 17
--

[.degrade]
=== Einfacher Funktionsaufruf

[source,java]
----
import java.lang.invoke.*;
import jdk.incubator.foreign.*;

class CallPid {
  public static void main(String... p) throws Throwable {
    var libSymbol = CLinker.systemLookup().lookup("getpid").get();      <1>
    var javaSig = MethodType.methodType(long.class);                    <2>
    var nativeSig = FunctionDescriptor.of(CLinker.C_LONG);              <3>

    CLinker cABI = CLinker.getInstance();
    var getpid = cABI.downcallHandle(libSymbol, javaSig, nativeSig);

    System.out.println((long) getpid.invokeExact());  
  }
}
----
<1> adressiertes _Symbol_ – hier via Lookup in den System Libraries
<2> gewünschte _Java-Signatur_ des Java Foreign Handles
<3> _Ziel-Signatur_ der aufzurufenden C-Funktion

[.degrade]
=== Aufruf mit Pointer (1/2)
[source,c]
----
int crypto_box_seal(unsigned char *c, const unsigned char *m,
                    unsigned long long mlen, const unsigned char *pk)
----
[.decent.xx-small]#…liest Text aus `*m` und schreibt 
verschlüsseltes Ergebnis nach `*c`# +
↓
[source.fragment,java]
----
var cryptoBoxSeal = CLinker.getInstance().downcallHandle(
        SymbolLookup.loaderLookup().lookup("crypto_box_seal").get(),
        MethodType.methodType(int.class,
                              MemoryAddress.class, MemoryAddress.class,
                              long.class, MemoryAddress.class),
        FunctionDescriptor.of(C_INT,
                              C_POINTER,   C_POINTER,
                              C_LONG_LONG, C_POINTER) );
----




[.small.degrade]
=== Aufruf mit Pointer (2/2)

.Foreign Heap wird vom GC via `ResourceScope` verwaltet
[source,java]
----
try (var scope = ResourceScope.newConfinedScope()) { … }
----

[.fragment]
.String-Konvertierung & Kopie in nativen Heap
[source,java]
----
var plainMsg = CLinker.toCString("abc", scope);
----

[.fragment]
.Reservierung Ziel-Speicherbereich
[source,java]
----
var cipherText = scope.allocate(48 + plainMsg.byteSize(), scope);
var pubKey = scope.allocateArray(C_CHAR, publicKey);
----

[.fragment]
.Aufruf & Rückgabe
[source,java]
----
var ret = (int) cryptoBoxSeal.invokeExact(
            cipherText.address(), plainMsg.address(), 
            (long) plainMsg.byteSize(), pubKey.address());
return cipherText.toByteArray();
----



=== Helferlein `jextract`

Generiert einen API Wrapper als `.class` oder `.java` +
direkt aus `.h`-Dateien mit den notwendigen Foreign API-Aufrufen. +
[.decent.xx-small]#Nicht in JDK 17 direkt enthalten; sondern via Panama EAP JDK Builds.#

[.fragment]
--
[source,shell]
----
$ jextract -t de.bentolor /usr/include/unistd.h
----

[source,java]
----
import de.bentolor.unistd_h;

class CallPid {
   public static void main(String[] args) {
      System.out.println( unistd_h.getpid() );
      System.out.println( ProcessHandle.current().pid() );
  }
}
----
--



[.refs]
--
https://jdk.java.net/panama/[Project Panama Early-Access Builds]
--




[.lightbg,background-video="hammer.mp4",background-video-loop="true",background-opacity="0.7"]
== Tooling

=== Packaging Tool `jpackage` [jep]#https://openjdk.java.net/jeps/343[JEP 343]# [jep]#https://openjdk.java.net/jeps/392[JEP 392]#

Werkzeug zum Erstellen & Paketieren eigenständiger Java-Applikationen 

[.col2]
--

.icon:box-open[] Native Installer
icon:windows[] → `.msi` und `.exe` +
icon:apple[] → `.pkg` und `.dmg` +
icon:linux[] → `.deb` und `.rpm` +
--

[.col2]
--

.icon:sliders-h[] Konfiguration
Start-Optionen (JVM/App) +
Meta-Daten +
Datei-Assoziationen +
--
 
.icon:ban[] Nicht im Scope
Splash-Screen +
Auto-Update Mechanismus



[.notes]
--
* Preview mit JDK14, stabilisiert mit JDK16
* Native Installerformate für natürliche Installations UX
--

[%notitle,background-video="jpackagerfast.mp4",background-size="contain",background-color="black"]
=== Installation packages with `jpackager` [jep]#https://openjdk.java.net/jeps/343[JEP 343]# [jep]#https://openjdk.java.net/jeps/392[JEP 392]#


[.degrade]
=== Verwendung `jpackage`

[source.bgap,bash]
----
$ jpackage --name myapp --input lib \
           --main-jar main.jar --main-class myapp.Main
----

[%step.col3-l.small]
--
.Allgemeines
[source]
----
--app-version <version>
--copyright <string>
--description <string>
--license-file <file>
--name <string>
--vendor <string>
----
--

[%step.col3-c.small]
--
.File associations
Definition via Propertydatei 

[decent]#Dateiendung, MIME-Typ, Icon, Beschreibung#
--

[%step.col3-r.small]
--
.Launcher
* Default Arguments
* JVM Options
* Zusätzliche Launcher
--

[%step]
.Plattform
[.decent.x-small]#wie Linux-Menügruppe, Mac Code-Signing, Windows UUID & Shortcut, u.a.#


[.notes]
--
* Für Windows muss _Wix_ installiert sein
--


=== `javadoc`

Das Javadoc-Tool hat mit JDK16 umfassende Verbesserungen erfahren…

[.col2s.x-small.decent.lgap]
* Verbesserte Suche
* Neues/Verbessertes _New_, +
  _Deprecated_, _Related Package_
* Javadoc Errors zeigen Code-Ausschnitt
* Mobile-friendly Layout
* autom. Links zur JDK API
* Checks für leere Absätze
* Bessere "Typ"-Terminologie
* Bessere Darstellung von `@see`, Paket-Zusammenfassungen, Nested Class, u.a.
* HTML4 & IFRAME Support entfernt

[%step.col2.small]
--
.`@return` Shortcut
[source.small,java]
----
/** {@return The max value in the array} */
public static int max(final int... array) {
----
↓ +
image:return.png[Javadoc Result,role="plain"]
--


[%notitle,background-video="javadoc.mp4",background-video-loop="false",background-size="contain"]
=== Javadoc Demo





=== jdeps






== GraalVM
=== Überblick & Stand
* Polyglott VM
* SubstrateVM: AoT Compiler
* GraalVM Community & Enterprise

//[%notitle,background-image="graalvm-architecture.png"]
=== Project Metropolis
image::graalvm-architecture.png[GraalVM ecosystem]

[.notes]
--
* Polyglot VM: Execute multiple language with zero overhead
* Can run in multiple environments; Can produce native images
* Zero-overhead interop
--

=== GraalVM -- Polyglot VM [jep]#https://openjdk.java.net/jeps/243[JEP 243]# [jep]#https://openjdk.java.net/jeps/246[JEP 246]# [jep]#https://openjdk.java.net/jeps/295[JEP 295]#
[.col2]
--
* *Ahead-of time compiler* (AoT)
* Generic VM +
 for *different languages* +
→ _JVM_ (Java, Kotlin, Scala, …) +
→ _LLVM_ (C, C++) → native +
→ _Java_ Script, Python, Ruby, R
--
[.col2]
--
* Shared Runtime → Zero overhead for language interop
* *Native executables* +
  (GraalVM on SubstrateVM) +
  → Much smaller startup & memory
--
[.clear.decent]
--
.AoT can be used today:
[.x-small]#`java -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler`#
--
[.notes]
--
* Multiple parts:
** AoT Compiler
** Graal VM / Substrate VM as runtime
* AoT → improved startup time vs. JIT
* Limitations: Dynamic (Reflection); highly experimental
* AoT Compile can be used today
--

=== Frameworks
* Helidon, Quarkus.io, Micronaut, (?Spring Fu, Javalin, Ktor, Vert.x)
* zielen auf GraalVM AoT Compilation & Microservices
* z.B. Dependency Resolver zur Compiletime via Annotation Processing vs. Laufzeit
* Java CLI native image

=== Demo
* xxx




== Details & Maintenance

=== Strongly Encapsulate JDK Internals by Default 
* JEP 411 (JDK 17): The Security Manager was deprecated for removal
[.notes]
--
* Java currently supports two different models for floating-point operations. One is the strict floating-point semantics, which are supported by AMD and Intel microprocessors. However, Java’s default is a slightly different floating-point semantics scheme. This split occurred back in Java SE 1.2, when there were some issues with the x87 math coprocessor. It’s no longer needed because all of today’s processors support SSE2 (Streaming SIMD Extensions 2) and later extensions in a way that eliminates the need for the default semantics. Therefore JEP 306’s intention is to make floating-point operations consistently strict by restoring the original floating-point semantics to the language and JVM.

Strong encapsulation for JDK internals, except for critical internal APIs such as sun.misc.Unsafe, would make it no longer be possible to relax the strong encapsulation of internal elements via a single command-line option, as was doable in JDK 9 through JDK 16. Goals of the plan include improving security and maintainability of the JDK and encouraging developers to migrate from internal elements to standard APIs.
--




=== Always stirct fps
https://openjdk.java.net/jeps/306

[.notes]
--
* https://openjdk.java.net/jeps/306 JEP 306 (JDK 17): Always-strict floating-point semantics have been restored

With the restoration of always-strict floating point semantics, floating-point operations will be made consistently strict, rather than having both strict floating point semantics (strictfp) and subtly different default floating point semantics. This restores the original floating point semantics to the language and VM, matching the semantics before the introduction of strict and default floating point modes in Java Standard Edition 1.2. Goals of this effort include easing development of numerically sensitive libraries including java.lang.Math and java.lang.StrictMath. The impetus for changing the default floating point semantics in the late-1990s stemmed from bad interaction between the original Java language and JVM semantics and some peculiarities of the x87 floating point coprocessor instruction set of the popular x86 architecture. Matching the exact floating point semantics in all cases, including subnormal operands and results, required large overheads of additional instructions. Matching the results in the absence of overflow or underflow could be done with less overhead and that is roughly what is allowed by the revised default floating point semantics introduced in Java SE 1.2. But the SSE2 (Streaming SIMD Extensions 2) extensions, shipped in Pentium 4 and later processors starting circa 2001, could support strict JVM floating point operations in a straightforward manner without undue overhead. Since Intel and AMD support SSE2 and later extensions that allow natural support of strict floating point semantics, the technical motivation for having a default floating point semantics different than strict no longer exists.
--

=== Plattform 
.Architekturen
* JEP 391: macOS/AArch64 Port
https://openjdk.java.net/jeps/391

.Unicode
* x

[.notes]
--
Porting the JDK to MacOS/AArch64 in response to Apple’s plan to transition its Macintosh computers from x64 to AArch64. An AArch64 port for Java already exists for Linux and work is underway for Windows. Java builders expect to reuse existing AArch64 code from these ports by employing conditional compilation, as is the norm in ports of the JDK, to accommodate differences in low-level conventions such as the application binary interface and the set of reserved processor registers. Changes for MacOS/AArch64 risk breaking the existing Linux/AArch64, Windows/AArch64, and MacOS/x64 ports, but the risk will be reduced through pre-integration testing.
--



=== Kryptographie
* Cipher Streams & Signatures


== Fazit


[%notitle, background-image="tweet-jdk-evolving.png"]
=== Bottom line
TODO



[.lightbg,background-video="industrial.mp4",background-video-loop="true",background-opacity="0.6"]
=== Ressourcen

[.col3-l.xx-small]
--
.Referenzwerke
* xx
* https://chriswhocodes.com/vm-options-explorer.html[VM Options Explorer]
* https://docs.oracle.com/en/java/javase/17/gctuning/available-collectors.html[HotSpot Tuning Guide: Available Collectors]

.Artikel
* https://blog.arkey.fr/2021/09/04/a-practical-look-at-jep-412-in-jdk17-with-libsodium/[A practical look at JEP-412]
* https://docs.oracle.com/en/java/javase/14/vm/class-data-sharing.html[Application Class-Data Sharing]
* http://www.oracle.com/pls/topic/lookup?ctx=javase14&id=dynamic_CDS_archive[Dynamic CDS Archive]
* https://blogs.oracle.com/javamagazine/understanding-the-jdks-new-superfast-garbage-collectors[Understanding the JDK’s New Superfast Garbage Collectors]
* https://entwickler.de/java/kurze-pause[Kurze Pause]

.Tools
* http://jdk.java.net/jmc/[JDK Mission Control]

.Weiterführendes
* https://www.youtube.com/watch?v=B8k9QGvPxC0[State of Project Panama]


.Tools
* https://www.graalvm.org/[GraalVM]
* https://openjdk.java.net/projects/jmc/8/[JDK Flight Mission Control 8]
* https://chriswhocodes.com/hotspot_options_openjdk17.html[VM Options Explorer ]
--


[.col3-c.xx-small]
--
.Contact
* Twitter https://twitter.com/bentolor[*@bentolor*]
* Email: mailto:ben@tolor.de[]

.Sources
* icon:code-branch[Github] https://github.com/bentolor/java9to13[*GitHub Repo with Source Code Examples & Slide Sources*]
* https://de.freeimages.com/photographer/s_lim363-49742[Background image],
  https://www.pexels.com/video/a-bee-on-a-yellow-flower-2048452/[Flowers], https://www.pexels.com/video/relaxing-at-the-beach-1449880/[Relaxing at the beach], https://www.pexels.com/video/cup-of-coffee-on-top-of-coffee-beans-855414/[Coffee Beans], https://www.pexels.com/video/close-up-video-of-a-woman-studying-855418/[Woman studying], https://www.pexels.com/video/white-keyboard-2219383/[White keyboard], https://www.pexels.com/video/jack-hammering-pavement-855956/[Jackhammer], https://www.pexels.com/video/globe-plasma-light-1192113/[Plasma Light], https://www.pexels.com/video/heavy-equipment-loading-cement-2073130/[Industrial Site]
--

[.col3-r.small]
--
* xxx
--

[pass]
++++
<script src="./live.js"></script>
++++

//include::presentation-intro.adoc[] 
//include::presentation-agenda.adoc[] 
//include::presentation-highlights.adoc[] 
//include::presentation-language.adoc[] 
//include::presentation-api.adoc[] 
//include::presentation-tooling.adoc[]
//include::presentation-outlook.adoc[]
//include::presentation-appendix.adoc[]
